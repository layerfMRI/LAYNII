
#include "../dep/laynii_lib.h"

int show_help(void) {
    printf(
    "LN2_RIMIFY: Convert segmentation files generated by other softwares\n"
    "           (fsl, freesurfer, brainvoyager etc) into a 'rim' file that is\n"
    "           commonly used in other LAYNII programs (e.g. LN2_LAYERS).\n"
    "\n"
    "Usage:\n"
    "    LN2_RIMIFY -input data_file.nii -innergm 2 -outergm 3 -gm 1\n"
    "    LN2_RIMIFY -input data_file.nii -innergm 150 -outergm 0 -gm 100\n"
    "    LN2_RIMIFY -input data_file.nii -innergm 240 -outergm 0 -gm 243\n"
    "    ../LN2_RIMIFY -input sc_rim.nii -innergm 2 -outergm 1 -gm 3 -output rimified_rim.nii \n"
    "    TODO: Add freesurfer example\n"
    "\n"
    "Options:\n"
    "    -help    : Show this help.\n"
    "    -input   : Input multi-tissue segmentation image (2D or 3D).\n"
    "    -innergm : Integer that will be regarded as the inner gray matter\n"
    "               boundary (1). White matter tissue label can be used here.\n"
    "    -outergm : Integer that will be regarded as the outer gray matter\n"
    "               boundary (2). CSF tissue label can be used here.\n"
    "    -gm      : Integer that will be regarded as pure gray matter (3).\n"
    "    -output  : (Optional) Output filename, including .nii or\n"
    "               .nii.gz, and path if needed. Overwrites existing files.\n"
    "\n"
    "Notes:\n"
    "    - Values not indicated as innergm, outergm or gm will be 0 in\n"
    "      the output image.\n"
    "    - If you do not have a specific outer gray matter tissue, you might\n"
    "      consider '0' to use all non-brain voxels as outer gray matter.\n"
    "\n");
    return 0;
}

int main(int argc, char *argv[]) {
    bool use_outpath = false ;
    char *fin = NULL, *fout = NULL;
    int ac;
    int innergm, outergm, gm;
    if (argc < 3) return show_help();

    // Process user options
    for (ac = 1; ac < argc; ac++) {
        if (!strncmp(argv[ac], "-h", 2)) {
            return show_help();
        } else if (!strcmp(argv[ac], "-input")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -input\n");
                return 1;
            }
            fin = argv[ac];
            fout = fin;
        } else if (!strcmp(argv[ac], "-innergm")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -innergm\n");
                return 2;
            }
            innergm = std::stoi(argv[ac]);
        } else if (!strcmp(argv[ac], "-outergm")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -outergm\n");
                return 2;
            }
            outergm = std::stoi(argv[ac]);
        } else if (!strcmp(argv[ac], "-gm")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -gm\n");
                return 2;
            }
            gm = std::stoi(argv[ac]);
        } else if (!strcmp(argv[ac], "-output")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -output\n");
                return 2;
            }
            use_outpath = true ;
            fout = argv[ac];
        } else {
            fprintf(stderr, "** invalid option, '%s'\n", argv[ac]);
            return 1;
        }
    }

    if (!fin) {
        fprintf(stderr, "** missing option '-input'\n");
        return 1;
    }

    // Read input dataset
    nifti_image *nii = nifti_image_read(fin, 1);
    if (!nii) {
        fprintf(stderr, "** failed to read NIfTI from '%s'\n", fin);
        return 2;
    }

    log_welcome("LN_RIMIFY");
    log_nifti_descriptives(nii);

    cout << innergm << " | " << outergm << " | " << gm << endl;

    // Get dimensions of input
    const int size_x = nii->nx;
    const int size_y = nii->ny;
    const int size_z = nii->nz;
    const int nr_voxels = size_z * size_y * size_x;

    // Prepare images
    nifti_image *nii_in = copy_nifti_as_int16(nii);
    int16_t* nii_in_data = static_cast<int16_t*>(nii_in->data);
    nifti_image *nii_rim = copy_nifti_as_int16(nii_in);
    int16_t* nii_rim_data = static_cast<int16_t*>(nii_rim->data);

    // Swap input tissue labels with LAYII rim file standards
    for (int i = 0; i != nr_voxels; ++i) {
        if (*(nii_in_data + i) == innergm){
            *(nii_rim_data + i) = 2;   // Renzo touched this on June 12th
        } else if (*(nii_in_data + i) == outergm){
            *(nii_rim_data + i) = 1;  // Renzo touched this on June 12th
        } else if (*(nii_in_data + i) == gm){
            *(nii_rim_data + i) = 3;
        } else {
            *(nii_rim_data + i) = 0;
        }
    }

    // Save
    save_output_nifti(fout, "rim", nii_rim, true, use_outpath);

    cout << "  Finished." << endl;
    return 0;
}
