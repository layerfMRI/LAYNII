
#include "../dep/laynii_lib.h"
#include <limits>


int show_help(void) {
    printf(
    "LN2_RIMIFY: Convert segmentation files generated by other software\n"
    "           (fsl, freesurfer, brainvoyager etc) into a 'rim' file that is\n"
    "           commonly used in other LAYNII programs (e.g. LN2_LAYERS).\n"
    "\n"
    "Usage:\n"
    "    LN2_RIMIFY -input data_file.nii -innergm 2 -outergm 3 -gm 1\n"
    "    LN2_RIMIFY -input data_file.nii -innergm 150 -outergm 0 -gm 100\n"
    "    LN2_RIMIFY -input data_file.nii -innergm 240 -outergm 0 -gm 243\n"
    "    ../LN2_RIMIFY -input sc_rim.nii -innergm 2 -outergm 1 -gm 3 -output rimified_rim.nii \n"
    "    TODO: Add freesurfer example\n"
    "\n"
    "Options:\n"
    "    -help         : Show this help.\n"
    "    -input        : Input multi-tissue segmentation image (2D or 3D).\n"
    "    -innergm      : Integer that will be regarded as the inner gray matter\n"
    "                    boundary (1). White matter tissue label can be used here.\n"
    "    -outergm      : Integer that will be regarded as the outer gray matter\n"
    "                    boundary (2). CSF tissue label can be used here.\n"
    "    -gm           : Integer that will be regarded as pure gray matter (3).\n"
    "    -brainvoyager : (Optional) Add this flag to automatically convert BrainVoyager.\n"
    "                    cortical white and gray matter segmentations to 'rim' format.\n"
    "                    The input should be a nifti file converted from a VMR file\n"
    "                    containing 100 & 150, or 240 & 243 labeled voxels.\n"
    "                    When given '-innergm', '-outergm', and '-gm' parameters are not used.\n"
    // "    -freesurfer   : (Optional) Add this flag to automatically convert Freesurfer.\n"
    // "                    cortical white and gray matter segmentation to 'rim' format.\n"
    // "                    'aseg' files containing 100 & 150, or 240 & 243 labeled voxels.\n"
    "    -output       : (Optional) Output filename, including .nii or\n"
    "                    .nii.gz, and path if needed. Overwrites existing files.\n"
    "\n"
    "Notes:\n"
    "    - Values not indicated as innergm, outergm or gm will be 0 in\n"
    "      the output image.\n"
    "    - If you do not have a specific outer gray matter tissue, you might\n"
    "      consider '0' to use all non-brain voxels as outer gray matter.\n"
    "\n");
    return 0;
}

int main(int argc, char *argv[]) {
    bool use_outpath = false, mode_custom = true, mode_brainvoyager=false;
    char *fin = NULL, *fout = NULL;
    int ac;
    int innergm=std::numeric_limits<int>::min();
    int outergm=std::numeric_limits<int>::min();
    int gm=std::numeric_limits<int>::min();
    if (argc < 3) return show_help();

    // Process user options
    for (ac = 1; ac < argc; ac++) {
        if (!strncmp(argv[ac], "-h", 2)) {
            return show_help();
        } else if (!strcmp(argv[ac], "-input")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -input\n");
                return 1;
            }
            fin = argv[ac];
            fout = fin;
        } else if (!strcmp(argv[ac], "-innergm")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -innergm\n");
                return 2;
            }
            innergm = std::stoi(argv[ac]);
        } else if (!strcmp(argv[ac], "-outergm")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -outergm\n");
                return 2;
            }
            outergm = std::stoi(argv[ac]);
        } else if (!strcmp(argv[ac], "-gm")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -gm\n");
                return 2;
            }
            gm = std::stoi(argv[ac]);
        } else if (!strcmp(argv[ac], "-brainvoyager")) {
            mode_custom = false;
            mode_brainvoyager = true;
        } else if (!strcmp(argv[ac], "-output")) {
            if (++ac >= argc) {
                fprintf(stderr, "** missing argument for -output\n");
                return 2;
            }
            use_outpath = true ;
            fout = argv[ac];
        } else {
            fprintf(stderr, "** invalid option, '%s'\n", argv[ac]);
            return 1;
        }
    }

    if (!fin) {
        fprintf(stderr, "** missing option '-input'\n");
        return 1;
    }

    if (mode_custom) {
        if (innergm == std::numeric_limits<int>::min()){
            fprintf(stderr, "** missing option '-innergm'\n");
            return 1;
        }
        if (outergm == std::numeric_limits<int>::min()){
            fprintf(stderr, "** missing option '-outergm'\n");
            return 1;
        }
        if (gm == std::numeric_limits<int>::min()){
            fprintf(stderr, "** missing option '-gm'\n");
            return 1;
        }
    }


    // Read input dataset
    nifti_image *nii = nifti_image_read(fin, 1);
    if (!nii) {
        fprintf(stderr, "** failed to read NIfTI from '%s'\n", fin);
        return 2;
    }

    log_welcome("LN_RIMIFY");
    log_nifti_descriptives(nii);

    // Get dimensions of input
    const int size_x = nii->nx;
    const int size_y = nii->ny;
    const int size_z = nii->nz;
    const int nr_voxels = size_z * size_y * size_x;

    // Prepare images
    nifti_image *nii_in = copy_nifti_as_int16(nii);
    int16_t* nii_in_data = static_cast<int16_t*>(nii_in->data);
    nifti_image *nii_rim = copy_nifti_as_int16(nii_in);
    int16_t* nii_rim_data = static_cast<int16_t*>(nii_rim->data);

    // Swap input tissue labels with LAYII rim file standards
    if (mode_custom == true) {
        cout << "  Custom mode is selected." << endl;
        cout << "    Inner GM: " << innergm << "\n";
        cout << "    Outer GM: " << outergm << "\n";
        cout << "    GM: " << gm << "\n" << endl;
        for (int i = 0; i != nr_voxels; ++i) {
            if (*(nii_in_data + i) == innergm){
                *(nii_rim_data + i) = 2;
            } else if (*(nii_in_data + i) == outergm){
                *(nii_rim_data + i) = 1;
            } else if (*(nii_in_data + i) == gm){
                *(nii_rim_data + i) = 3;
            } else {
                *(nii_rim_data + i) = 0;
            }
        }
    } else if (mode_brainvoyager == true) {
        cout << "  BrainVoyager mode is selected." << endl;
        cout << "    Therefore not using innergm, outergm, and gm parameters even if they are given." << endl;
        for (int i = 0; i != nr_voxels; ++i) {
            if (*(nii_in_data + i) == 240 || *(nii_in_data + i) == 150) {
                *(nii_rim_data + i) = 2;
            } else if (*(nii_in_data + i) == 243 || *(nii_in_data + i) == 100) {
                *(nii_rim_data + i) = 3;
            } else {
                *(nii_rim_data + i) = 1;
            }
        }
    }

    // Save
    save_output_nifti(fout, "rim", nii_rim, true, use_outpath);

    cout << "  Finished." << endl;
    return 0;
}
